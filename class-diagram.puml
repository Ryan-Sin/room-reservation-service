@startuml
class Member {
  -String name
  -List<Reservation> reservations
  -List<PaymentHistory> paymentHistories
  +registerReservation(reservation: Reservation): void
  +confirmReservation(): List<Reservation>
  +confirmPaymentHistory(): List<PaymentHistory>
}

class Home {
  +getProvideRoomInfos(): List<Room>
  +getAvailableRoomOnDate(DateRange): List<Accommodation>
  +reserve(Member, DateRange, Accommodation): void
}

class Room {
  -ZoneId zoneId
  -String name
  -long price
  +showRoomInfos(): List<Room>
  +calculateRoomPayment(DateRange): long
}

class Accommodation {
  -Room room
  -AccommodationStatus status
  +showSpecificDateAccommodations(DateRange): List<Accommodation>
  +changeToCompletionStatus(Accommodation): boolean
  -pendingReservation(): void
  +getPaymentAmount(DateRange): long
}

enum AccommodationStatus {
  BLOCK
  AVAILABLE
  PENDING
  COMPLETED
}

class Reservation {
  -Long reservationId
  -Member member
  -DateRange reservationDate
  -Accommodation accommodation
  +getReservationAmount(): long
  +completeReservation(): void
}

class DateRange {
  -Instant start
  -Instant end
}

class Address {
  -Long addressId
  -String address
  -String roadAddress
  -String detailAddress
  -double latitude
  -double longitude
  -String postCode
  -String zone
  +registerAddress(Room)
}

class Review {
  -Member member
  -Room room
  -String title
  -String description
  -double scope
  -Instant createdAt
  +registerReview(Member, Room)
}

class File {
  +uploadFile()
}

class CategoryManager {
  -List<Category> categories
  +addCategory(category: Category): List<Category>
  +addSubCategory(category: Category, subCategory: SubCategory): List<Category>
  +getCategories(): List<Category>
  +getSubCategories(name: String): Category
}

class Category {
  -Long categoryId
  -String name
  -String description
  -int sort
  -List<SubCategory> subCategories
  +createSubCategory(subCategory: SubCategory): void
}

class SubCategory {
  -Long subCategoryId
  -String name
  -String description
  -int sort
  -int depth
}

enum PaymentMethod {
  REGULAR_CARD
  REGISTER_CARD
}

class Payment {
 -List<PaymentProcess> paymentProcesses
 +requestPayment(reservation: Reservation, paymentMethod: PaymentMethod, amount: long): void
 +cancelPayment(reservation: Reservation): void
 -routingPaymentProcess(paymentMethod: PaymentMethod): PaymentProcess
}

class RegisterCard {
 +registerCard(member: Member, pgType: String): void
}

interface PaymentProcess {
 +support(paymentMethod: PaymentMethod): boolean
 +pay(reservation: Reservation, amount: long): PaymentInfo
 +cancel(transactionId: String): void
}

class RegularCardPayment implements PaymentProcess {
 +support(paymentMethod: PaymentMethod): boolean
 +pay(reservation: Reservation, amount: long): PaymentInfo
 +cancel(transactionId: String): void
}

class RegisterCardPayment implements PaymentProcess  {
 +support(paymentMethod: PaymentMethod): boolean
 +pay(reservation: Reservation, amount: long): PaymentInfo
 +cancel(transactionId: String): void
}

class PaymentHistory {
 -Long paymentHistoryId
 -PaymentStatus status
 -Member member
 -Reservation reservation
 -PaymentMethod paymentMethod
 -String transactionId
 -Long amount
 -String receipt
 -Instant createdAt
}

enum PaymentStatus {
 PAY
 CANCEL
 PARTIAL_CANCEL
}

class PaymentInfo {
 -String transactionId
 -String receipt
}

class PaymentValidator {
 +assertMismatchPaymentAmount(reservation: Reservation, paymentAmount: long): void
}

@enduml